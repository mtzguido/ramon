#!/usr/bin/env python3

from parse import *

def load_file(fn):
    loads = {}
    rloads = {}
    marks = {}
    mems = {}
    nmarks = 0

    with open(fn) as f:
        for line in f:
            if not (search("poll" , line)):
                continue
            wall = search("wall={:g}", line).fixed[0]
            usage = search("usage={:g}", line).fixed[0]

            r = search("mem={:d}{:l}", line).fixed
            mem = r[0]
            memU = r[1]
            match memU:
                case "KiB":
                    mem *= 1000;
                case "MiB":
                    mem *= 1000000;
                case "GiB":
                    mem *= 1000000000;

            load = search("load={:g}", line).fixed[0]
            rload = search("rootload={:g}", line).fixed[0]
            loads[wall] = load
            rloads[wall] = rload
            mems[wall] = mem
    with open(fn) as f:
        for line in f:
            if not (search("mark" , line)):
                continue
            mark = search("str={:S}", line).fixed[0]
            wall = search("wall={:g}", line).fixed[0]
            marks[nmarks] = (mark, wall)
            nmarks=nmarks+1

    return rloads, loads, mems, marks

def plot(fn, rloads, loads, mems, marks):
    import matplotlib.pyplot as plt
    import numpy as np
    from math import ceil

    plt.figure(figsize=(12, 4), dpi=400)

    x_axis = []
    y_axis = []
    y2_axis = []
    y3_axis = []
    for t in loads.keys():
        x_axis.append(t)
        y_axis.append(loads[t])
        y2_axis.append(mems[t] / (1<<30))
        y3_axis.append(rloads[t])

    maxx = ceil(max(loads.keys(), default=1))
    maxy = ceil(max(loads.values(), default=1))
    maxy = ceil(max(maxy, ceil(max(mems.values(), default=1)) / (1<<30)))
    nmarks = len(marks.keys())
    #  print("maxx = {}".format(maxx));
    #  print("maxy = {}".format(maxy));
    #  print("nmarks = {}".format(nmarks));

    plt.fill_between(x_axis, 0, y_axis)
    plt.fill_between(x_axis, 0, y3_axis)
    plt.plot(x_axis, y2_axis, color='C2', linewidth=0.5)

    lasttime = -10
    lasty = 0
    marki = 0
    for k in marks.keys():
        (tag, time) = marks[k]
        #  if (lasttime + 50 >= time):
        #      y = lasty - 2
        #  else:
        #      y = 0
        y = (nmarks - marki) / nmarks * maxy
        plt.vlines(time, 0, maxy, colors='C1', label=tag, linestyles='dashed', linewidth=0.3);
        plt.text(time, y, tag, rotation=45, size=4)
        #  lasttime = time
        #  lasty = y
        marki = 1 + marki
    #plt.legend()
    plt.hlines(range(1+maxy), 0, maxx, colors='gray', linestyles='solid', alpha=0.5, linewidth=0.3);

    plt.xlabel("Wall clock time")
    plt.ylabel("Load / Memory(GiB)")

    plt.title("Load average and memory across time")
    plt.figtext(0.006, 0.02, "Generated by ramon", size=4)

    imagefn = fn + ".png"
    plt.savefig(imagefn)
    print("Saved image in {}".format(imagefn))
    return imagefn

def render_one(file):
    rloads, loads, mems, marks = load_file(file)

    img = plot(file, rloads, loads, mems, marks)

    return img

def main():
    from os import listdir
    from os.path import isfile, isdir
    import sys
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("file", help="ramon output with --poll (or directory, in which case we render all .res files)")
    parser.add_argument("--open", action="store_true", help="open the generated image")
    args = parser.parse_args()

    file = args.file

    if isdir(file):
        for f in listdir(file):
            if isfile(f) and f.endswith(".res") and not isfile(f + ".png"):
                render_one(f)
    else:
        img = render_one(file);
        if args.open:
            os.system("xdg-open " + img)

main()


# TODO
# - Use fill graph
# - show subinvocation as stacked area
# - better mark handling
# - SVG? PDF? Allow to zoom.
# - Soften?
